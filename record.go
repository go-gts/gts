package gts

import (
	"fmt"
	"io"
	"os"

	pars "gopkg.in/pars.v2"
)

// Record is the interface for sequence records with metadata and features.
type Record interface {
	Metadata() interface{}
	FeatureTable
	MutableSequence
}

// NewRecord creates a new record.
func NewRecord(meta interface{}, ff []Feature, p []byte) Record {
	seq := Seq(p)
	switch v := meta.(type) {
	case GenBankFields:
		return GenBank{v, FeatureList(ff), NewSequenceServer(seq)}
	default:
		err := fmt.Errorf("gts does not know how to create a record using metadata of type `%T`", v)
		panic(err)
	}
}

// DefaultFormatter returns the default formatter for the given record.
func DefaultFormatter(rec Record) Formatter {
	switch rec.Metadata().(type) {
	case GenBankFields:
		return GenBankFormatter{rec}
	default:
		return GenBankFormatter{rec}
	}
}

// NewRecordFormatter returns a new formatter for the given filetype.
func NewRecordFormatter(rec Record, filetype FileType) Formatter {
	switch filetype {
	case DefaultFile:
		return DefaultFormatter(rec)
	case GenBankFlat:
		return GenBankFormatter{rec}
	case JSONFile:
		return NewEncoderFormatter(rec, NewJSONEncoder)
	case YAMLFile:
		return NewEncoderFormatter(rec, NewYAMLEncoder)
	case MsgpackFile:
		return NewEncoderFormatter(rec, NewMsgpackEncoder)
	default:
		return DefaultFormatter(rec)
	}
}

// RecordParser attempts to parse a single sequence record.
var RecordParser = pars.Any(GenBankParser)

// RecordScanner scans one sequence record at a time.
type RecordScanner struct {
	s Scanner
	r Record
}

func newRecordScanner(r io.Reader) *MultiParserScanner {
	return NewMultiParserScanner(r,
		GenBankParser,
		genbankJSONParser,
		genbankYAMLParser,
		genbankMsgpackParser,
	)
}

// NewRecordScanner creates a new RecordScanner.
func NewRecordScanner(r io.Reader) *RecordScanner {
	return &RecordScanner{newRecordScanner(r), nil}
}

func filesize(f *os.File) int64 {
	stat, err := f.Stat()
	if err != nil {
		panic(err)
	}
	return stat.Size()
}

const maxFilesize int = 100 * (1 << 20)

// NewRecordFileScanner creates a new specialized RecordScanner based on the
// given filename.
func NewRecordFileScanner(f *os.File) *RecordScanner {
	state := pars.NewState(f)
	if size := filesize(f); size <= int64(maxFilesize) {
		state.Request(int(size))
	}

	var s Scanner
	switch Detect(f.Name()) {
	case GenBankFlat:
		s = NewParserScanner(state, GenBankParser)
	case JSONFile:
		s = NewMultiParserScanner(state,
			genbankJSONParser,
		)
	case YAMLFile:
		s = NewMultiParserScanner(state,
			genbankYAMLParser,
		)
	case MsgpackFile:
		s = NewMultiParserScanner(state,
			genbankMsgpackParser,
		)
	default:
		s = newRecordScanner(state)
	}
	return &RecordScanner{s, nil}
}

// Scan advances the Scanner to the next Record.
func (s *RecordScanner) Scan() bool {
	ok := s.s.Scan()
	if !ok {
		return false
	}
	s.r, ok = s.s.Value().(Record)
	return ok
}

// Record returns the most recent Record generated by a call to Scan.
func (s *RecordScanner) Record() Record {
	return s.r
}

// Err returns the first non-EOF error that was encountered by the Scanner.
func (s RecordScanner) Err() error {
	return s.s.Err()
}
