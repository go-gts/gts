package gts

import (
	"fmt"
	"io"
	"os"

	pars "gopkg.in/pars.v2"
)

// Record is the interface for sequence records with metadata and features.
type Record interface {
	FeatureTable
	MutableSequence
}

// NewRecord creates a new record.
func NewRecord(seq Sequence, ff []Feature) Record {
	switch info := seq.Info().(type) {
	case GenBankFields:
		return GenBank{info, FeatureList(ff), NewSequenceServer(Seq(seq))}
	default:
		err := fmt.Errorf("gts does not know how to create a record using metadata of type `%T`", info)
		panic(err)
	}
}

// RecordParser attempts to parse a single sequence record.
var RecordParser = pars.Any(GenBankParser)

// RecordScanner scans one sequence record at a time.
type RecordScanner struct {
	s Scanner
	r Record
}

func newRecordScanner(r io.Reader) *MultiParserScanner {
	return NewMultiParserScanner(r,
		GenBankParser,
		genbankJSONParser,
		genbankYAMLParser,
		genbankMsgpackParser,
	)
}

// NewRecordScanner creates a new RecordScanner.
func NewRecordScanner(r io.Reader) *RecordScanner {
	return &RecordScanner{newRecordScanner(r), nil}
}

func filesize(f *os.File) int64 {
	stat, err := f.Stat()
	if err != nil {
		panic(err)
	}
	return stat.Size()
}

const maxFilesize int = 100 * (1 << 20)

// NewRecordFileScanner creates a new specialized RecordScanner based on the
// given filename.
func NewRecordFileScanner(f *os.File) *RecordScanner {
	state := pars.NewState(f)
	if size := filesize(f); size <= int64(maxFilesize) {
		state.Request(int(size))
	}

	var s Scanner
	switch Detect(f.Name()) {
	case GenBankFile:
		s = NewParserScanner(state, GenBankParser)
	case JSONFile:
		s = NewMultiParserScanner(state,
			genbankJSONParser,
		)
	case YAMLFile:
		s = NewMultiParserScanner(state,
			genbankYAMLParser,
		)
	case MsgpackFile:
		s = NewMultiParserScanner(state,
			genbankMsgpackParser,
		)
	default:
		s = newRecordScanner(state)
	}
	return &RecordScanner{s, nil}
}

// Scan advances the Scanner to the next Record.
func (s *RecordScanner) Scan() bool {
	ok := s.s.Scan()
	if !ok {
		return false
	}
	if rec, ok := s.s.Value().(Record); ok && rec != nil {
		s.r = rec
		return true
	}
	return false
}

// Record returns the most recent Record generated by a call to Scan.
func (s *RecordScanner) Record() Record {
	return s.r
}

// Err returns the first non-EOF error that was encountered by the Scanner.
func (s RecordScanner) Err() error {
	return s.s.Err()
}
