package gts

import (
	"fmt"
	"io"

	pars "gopkg.in/pars.v2"
)

// Record is the interface for sequence records with metadata and features.
type Record interface {
	Metadata() interface{}
	FeatureTable
	MutableSequence
}

// NewRecord creates a new record/
func NewRecord(meta interface{}, ff []Feature, p []byte) Record {
	seq := Seq(p)
	switch v := meta.(type) {
	case GenBankFields:
		return GenBank{v, FeatureList(ff), NewSequenceServer(seq)}
	default:
		err := fmt.Errorf("gts does not know how to create a record using metadata of type `%T`", v)
		panic(err)
	}
}

// DefaultFormatter returns the default formatter for the given record.
func DefaultFormatter(rec Record) Formatter {
	switch rec.Metadata().(type) {
	case GenBankFields:
		return GenBankFormatter{rec}
	default:
		return GenBankFormatter{rec}
	}
}

// RecordParser attempts to parse a single sequence record.
var RecordParser = pars.Any(GenBankParser)

// RecordScanner scans one sequence record at a time.
type RecordScanner struct {
	state  *pars.State
	result pars.Result
	err    error
}

// NewRecordScanner creates a new RecordScanner.
func NewRecordScanner(r io.Reader) *RecordScanner {
	return &RecordScanner{pars.NewState(r), pars.Result{}, nil}
}

// Scan advances the Scanner to the next Record.
func (s *RecordScanner) Scan() bool {
	s.result, s.err = RecordParser.Parse(s.state)
	switch s.result.Value.(type) {
	case Record:
		return s.err == nil
	default:
		return false
	}
}

// Record returns the most recent Record generated by a call to Scan.
func (s *RecordScanner) Record() Record {
	if rec, ok := s.result.Value.(Record); ok {
		return rec
	}
	return nil
}

// Err returns the first non-EOF error that was encountered by the Scanner.
func (s RecordScanner) Err() error {
	return s.err
}
